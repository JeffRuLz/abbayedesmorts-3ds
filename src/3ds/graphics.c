#include "graphics.h"
#include <3ds.h>
#include <stdio.h>
#include <stdlib.h>

// These headers are generated by the build process
#include "vshader_shbin.h"
#include "lodepng.h"

#define CLEAR_COLOR 0x000000FF

// Used to transfer the final rendered display to the framebuffer
#define DISPLAY_TRANSFER_FLAGS \
	(GX_TRANSFER_FLIP_VERT(0) | GX_TRANSFER_OUT_TILED(0) | GX_TRANSFER_RAW_COPY(0) | \
	GX_TRANSFER_IN_FORMAT(GX_TRANSFER_FMT_RGBA8) | GX_TRANSFER_OUT_FORMAT(GX_TRANSFER_FMT_RGB8) | \
	GX_TRANSFER_SCALING(GX_TRANSFER_SCALE_NO))

// Used to convert textures to 3DS tiled format
// Note: vertical flip flag set so 0,0 is top left of texture
#define TEXTURE_TRANSFER_FLAGS \
	(GX_TRANSFER_FLIP_VERT(1) | GX_TRANSFER_OUT_TILED(1) | GX_TRANSFER_RAW_COPY(0) | \
	GX_TRANSFER_IN_FORMAT(GX_TRANSFER_FMT_RGBA8) | GX_TRANSFER_OUT_FORMAT(GX_TRANSFER_FMT_RGBA8) | \
	GX_TRANSFER_SCALING(GX_TRANSFER_SCALE_NO))

static DVLB_s* vshader_dvlb;
static shaderProgram_s program;
static int uLoc_projection;
static C3D_Mtx projection;

static C3D_RenderTarget* target;

void gfx_Init()
{
	gfxInitDefault();
	C3D_Init(C3D_DEFAULT_CMDBUF_SIZE);
	//consoleInit(GFX_BOTTOM, NULL);

	target = C3D_RenderTargetCreate(240, 400, GPU_RB_RGBA8, GPU_RB_DEPTH24_STENCIL8);
	C3D_RenderTargetSetClear(target, C3D_CLEAR_ALL, CLEAR_COLOR, 0);
	C3D_RenderTargetSetOutput(target, GFX_TOP, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);

	// Load the vertex shader, create a shader program and bind it
	vshader_dvlb = DVLB_ParseFile((u32*)vshader_shbin, vshader_shbin_size);
	shaderProgramInit(&program);
	shaderProgramSetVsh(&program, &vshader_dvlb->DVLE[0]);
	C3D_BindProgram(&program);

	// Get the location of the uniforms
	uLoc_projection = shaderInstanceGetUniformLocation(program.vertexShader, "projection");

	// Configure attributes for use with the vertex shader
	// Attribute format and element count are ignored in immediate mode
	C3D_AttrInfo* attrInfo = C3D_GetAttrInfo();
	AttrInfo_Init(attrInfo);
	AttrInfo_AddLoader(attrInfo, 0, GPU_FLOAT, 3); // v0=position
	AttrInfo_AddLoader(attrInfo, 1, GPU_FLOAT, 2); // v2=texcoord

	// Compute the projection matrix
	// Note: we're setting top to 240 here so origin is at top left.
	Mtx_OrthoTilt(&projection, 0.0, 400.0, 240.0, 0.0, 0.0, 1.0, true);

	// Configure the first fragment shading substage to just pass through the texture color
	// See https://www.opengl.org/sdk/docs/man2/xhtml/glTexEnv.xml for more insight
	C3D_TexEnv* env = C3D_GetTexEnv(0);
	C3D_TexEnvSrc(env, C3D_Both, GPU_TEXTURE0, 0, 0);
	C3D_TexEnvOp(env, C3D_Both, 0, 0, 0);
	C3D_TexEnvFunc(env, C3D_Both, GPU_REPLACE);

	// Configure depth test to overwrite pixels with the same depth (needed to draw overlapping sprites)
	C3D_DepthTest(true, GPU_GEQUAL, GPU_WRITE_ALL);
}

void gfx_Exit()
{
	// Free the shader program
	shaderProgramFree(&program);
	DVLB_Free(vshader_dvlb);

	C3D_Fini();
	gfxExit();
}

static int powOfTwo(int in)
{
	int out = 8;

	while (out < in)
		out *= 2;

	return out; 
}

Texture* gfx_LoadTexture(char* fname, RGB* colorKey)
{
	Texture* result = NULL;
	FILE* f;

	char fullpath[256];
	strcpy(fullpath, "romfs:");
	strcat(fullpath, fname);

	if ( (f = fopen(fullpath, "rb")) )
	{
		//Load PNG into a data buffer
		unsigned char* buffer;
		long bufferSize;

		fseek(f, 0, SEEK_END);
		bufferSize = ftell(f);

		buffer = (unsigned char*)malloc(bufferSize);
		
		fseek(f, 0, SEEK_SET);
		fread(buffer, 1, bufferSize, f);

		unsigned char* image;
		unsigned width, height;

		//Decode PNG
		lodepng_decode32(&image, &width, &height, buffer, bufferSize);
		free(buffer);

		//Create texture
		result = (Texture*)malloc(sizeof(Texture));
		result->w = width;
		result->h = height;

		result->data = (C3D_Tex*)malloc(sizeof(C3D_Tex));
		C3D_Tex* tex = (C3D_Tex*)result->data;

		//3DS textures must be a power of 2
		int w = powOfTwo(width);
		int h = powOfTwo(height);

		u8* gpusrc = linearAlloc(w*h*4);

		int r, g, b, a;
		long inc = 0; //in count
		long outc = 0; //out count

		for (int iy = 0; iy < h; iy++)
		{
			for (int ix = 0; ix < w; ix++)
			{
				r = g = b = a = 0;

				//Skips padded pixels due to the power of 2 requirement
				if (ix < width && iy < height)
				{
					b = image[inc];
					g = image[inc+1];
					r = image[inc+2];
					a = image[inc+3];
					inc += 4;

					//Transparency
					if (colorKey != NULL)
					{						
						if (r == colorKey->r && g == colorKey->g && b == colorKey->b)
							a = 0;
					}
				}

				gpusrc[outc] = a;
				gpusrc[outc+1] = r;
				gpusrc[outc+2] = g;
				gpusrc[outc+3] = b;
				outc += 4;
			}
		}

		// ensure data is in physical ram
		GSPGPU_FlushDataCache(gpusrc, w*h*4);

		// Load the texture and bind it to the first texture unit
		C3D_TexInit(tex, w, h, GPU_RGBA8);

		// Convert image to 3DS tiled texture format
		C3D_SafeDisplayTransfer ((u32*)gpusrc, GX_BUFFER_DIM(w,h), (u32*)tex->data, GX_BUFFER_DIM(w,h), TEXTURE_TRANSFER_FLAGS);
		gspWaitForPPF();

		C3D_TexSetFilter(tex, GPU_LINEAR, GPU_NEAREST);
		C3D_TexBind(0, tex);

		free(image);
		linearFree(gpusrc);
	}

	fclose(f);

	return result;
}

void gfx_FreeTexture(Texture* tex)
{
	C3D_TexDelete((C3D_Tex*)tex->data);
	tex->data = NULL;

	free(tex);
	tex = NULL;
}

void gfx_Clear()
{
	//New Frame Begin
	C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
	C3D_FrameDrawOn(target);
	
	C3D_SetViewport(-24, -72, 240.0, 400.0);
	C3D_SetScissor(GPU_SCISSOR_NORMAL, 24, 72, 216, 328);
	//						Bottom, Right, Top, Left

	// Update the uniforms
	C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
}

void gfx_Flip()
{
	//Frame End
	C3D_FrameEnd(0);
}

void gfx_RenderCopy(Texture* in, Rect* src, Rect* dst)
{
	if (in != NULL)
	{
		C3D_Tex* tex = (C3D_Tex*)in->data;

		C3D_TexBind(0, tex);

		C3D_TexEnv* env = C3D_GetTexEnv(0);
		C3D_TexEnvSrc(env, C3D_Both, GPU_TEXTURE0, 0, 0);
		C3D_TexEnvOp(env, C3D_Both, 0, 0, 0);
		C3D_TexEnvFunc(env, C3D_Both, GPU_REPLACE);

		float x = 0.0f;
		float y = 0.0f;
		float w = in->w;
		float h = in->h;

		if (dst != NULL)
		{
			x = dst->x;
			y = dst->y;
			w = dst->w;
			h = dst->h;
		}

		float cx1 = 0.0f;
		float cy1 = 0.0f;
		float cx2 = (float)(in->w) / (float)(tex->width);
		float cy2 = (float)(in->h) / (float)(tex->height);

		if (src != NULL)
		{
			w = src->w;
			h = src->h;

			cx1 = (float)(src->x) / (float)(tex->width);
			cy1 = (float)(src->y) / (float)(tex->height);
			cx2 = (float)(src->x + src->w) / (float)(tex->width);
			cy2 = (float)(src->y + src->h) / (float)(tex->height);
		}		

		// Draw a textured quad directly
		C3D_ImmDrawBegin(GPU_TRIANGLE_STRIP);
			C3D_ImmSendAttrib(x, y, 0.5f, 0.0f); // v0=position
			C3D_ImmSendAttrib(cx1, cy1, 0.0f, 0.0f);

			C3D_ImmSendAttrib(x, y+h, 0.5f, 0.0f);
			C3D_ImmSendAttrib(cx1, cy2, 0.0f, 0.0f);

			C3D_ImmSendAttrib(x+w, y, 0.5f, 0.0f);
			C3D_ImmSendAttrib(cx2, cy1, 0.0f, 0.0f);

			C3D_ImmSendAttrib(x+w, y+h, 0.5f, 0.0f);
			C3D_ImmSendAttrib(cx2, cy2, 0.0f, 0.0f);
		C3D_ImmDrawEnd();
	}
}